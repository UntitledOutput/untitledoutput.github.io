---
layout: post
title: "About Project Tomato"
date: 2025-04-02 12:00:00 -0500
categories: [Game Engine]
tags: [Game Development, WIP]
image: assets/images/eng401/attempt1.png
---

For about 3 years, I have been working on a game engine under the name Project Tomato. The engine has undergone many backend changes, from basic [OpenGL](https://www.opengl.org), to [Vulkan](https://www.vulkan.org), and finally, to [bgfx](https://bkaradzic.github.io/bgfx/).

## Starting Out With raylib

While I have little to no screenshots of the engine at the start of development, I have some that show my growth throughout this development journey.

I started out working with [raylib](https://raylib.com) around the, which was a C library I had found out about from a PolyMars video, where he recreated the same game for 5 different consoles, translating his raylib code to work for said consoles.

Starting out with raylib back at the start of 2023 was crucial to my development journey, as it was easy to understand, which allowed me to focus more on learning the basics of C/C++ (since I was coming from [Unity](https://unity.com) & [C#](https://learn.microsoft.com/en-us/dotnet/csharp/) )

My main issue with raylib was that it lacked crucial animation support for the project I had been working on. There were some projects that extended the abilities of raylib, but they were not maintained well, which eventually led to me moving away from using raylib for this project.

My experience with raylib was not bad, I just wanted more control over my rendering process, which led to me creating my own engine (even though raylib technically is not an engine, and I was still technically making my own engine on top of raylib anyways)

## Moving to OpenGL

My first attempts at creating a game engine were rough, as I wanted to do cross platform development (mainly with homebrew for Nintendo Switch etc.) 

## Moving to Vulkan

While I used OpenGL, I wanted even more control over the rendering process, so I moved to Vulkan.

Vulkan was extremely difficult to grasp, as the code required to sufficiently use the library was extensive. [The file I used for the rendering module](https://github.com/OutputGames/agl/blob/main/include/agl/agl.cpp#L233) ended up around 4000 lines by the end of my first iteration for this project, and most of it was written in about a weekend (which was filled with numerous errors and issues)

I also transitioned from using [GLFW](https://glfw.org) to using [SDL](https://libsdl.org) for the window creation, input detection, etc.

## The Real Work

The non graphical work on the engine really started to gain some traction in June-August 2023, where I was able to implement shadow rendering, PBR, and raytracing (not RTX based, though)

Many issues I had regarded physics engines, as I switched between libraries often, starting out using [ODE](https://ode.org), then moving to [Bullet](https://pybullet.org) for more maintained code, then moving to [Jolt](https://github.com/jrouwe/JoltPhysics) for GPU acceleration (which I never got to implementing), then eventually moving back to Bullet.

![pbr fail](/assets/images/eng401/pbr_fail.png)
_PBR Fail_

This screenshot shows my first attempts at implementing PBR (physically based rendering) using a tutorial on LearnOpenGL ([link to the tutorial series](https://learnopengl.com/PBR/Theory))

Some concepts such as shadow rendering and skeletal animation were difficult for me to truly grasp (since I was about 13 at the time), and the difficulties I faced with shadows and such are seen in some early screenshots

![shadow fail](/assets/images/eng401/shadow_fail.png)
_Shadow Fail_

Part of the reason behind my inability to understand these concepts were because I was just reading the code and implementing it into my engine. Something that would benefit me later into the process would be **actually reading the tutorials to understand the concepts**.

## Moving away from my first iteration

Something that may have caught your eye in these screenshots could be the engine UI shown, using [ImGUI](https://github.com/ocornut/imgui), where I really tried replicating the Godot/Unity feel.

![engine UI](/assets/images/eng401/fixed_shadow.png)
_Engine UI & Fixed Shadows_

While the engine UI was great, it led to me eventually implementing C# Scripting using the [Mono Runtime](https://www.mono-project.com/docs/advanced/runtime/) where I was able to directly create scripts and such to program objects, similar to Unity's MonoBehavior system.

My C# Scripting system worked well, but it caused a major performance drop in the engine, as average framerates dropped to ~40 FPS, from ~70 FPS.

### Looking Back 

My main issue other than the performance, was my inability to make games work outside of the traditional engine environment. At the time, I was unable to understand that I could just remove the ImGUI context, and allow the game to run without it. My worry was that the engine would be vulnerable, and certain malicious users could inject code into the game(s) I would have been making, and open an engine UI environment, with all the code I used for the engine UI out to use. Keep in mind, I did not understand macros that would obfuscate the visual engine code from the final game, like such

```c++
#ifdef USING_ENGINE_UI
    void DrawEngineUI();
#endif
```

If I was to utilize macros like this, then the engine UI code would not be built with the final game, preventing a hacker from using the engine UI.

Still, my scene serialization system and project system for the engine application were the same, so if a user got their hands on a scene file and the engine application, they would be able to load a game scene on their own and edit the game.

WHile all of these issues are fixable, at the time (November-December 2023), I did not feel like managing all the issues behind having a serialized scene and project system.

